% Pre-process an HRTF data set in various ways before employing it for 
% binaural rendering. At this point, we utilize a spatially subsampled 
% set of the published HRTF to lower computation resources for all 
% binaural renderings without losing spatial resolution.
% 
% The HRTFs are circ-shifted so that the signals start with the lowest 
% energy sample out of all incidence directions and both ears. The data 
% is then time-windowed to fade the start and the end of the HRTFs to 
% further limit artifacts from time discontinuities. The resulting data 
% set is exported with the suffix `_adjusted`, then utilized in the 
% remainder of the binaural rendering.
% 
% Additional versions of the data set are exported employing 
% direction-independent equalizations by the HRTFs diffuse-field 
% response (suffix `_diffuse`), by the former superimposed with the 
% Harman curve (suffix `_harman`), and by the diffuse-field response of 
% another measurement of the same HRTF (suffix `_reference`). Thereby, 
% respective minimum-phase and linear-phase variants of the generated 
% equalization filters are exported as impulse responses and plotted.
%
% -------------------------------------------------------------------------
%
% requires AKtools toolbox (run AKtoolsStart.m))
% $ git clone https://github.com/f-brinkmann/AKtools.git
% 
% requires Spherical-Harmonic-Transform toolbox
% $ git clone https://github.com/polarch/Spherical-Harmonic-Transform.git
% 
% requires data from
% ﻿https://doi.org/10.5281/zenodo.8206571
% 
% -------------------------------------------------------------------------
%
% Hannes Helmholz 13.05.2024
%
% -------------------------------------------------------------------------
clear; clc; close all;

addpath(genpath('dependencies'));

%% configuration
% generated by `x3_Subsample_Measurements.m` of the KEMAR HRTFs from
% https://publications.rwth-aachen.de/record/807373/files/Kemar_HRTF_sofa.sofa
[hrir_pub_sh_order, hrir_pub_file, hrir_pub_win_len] = ...
    deal(44, 'resources/HRIR_KEMAR/Kemar_HRTF_sofa_N44.sofa', 16);
[hrir_ref_file, hrir_ref_lf_rng, hrir_ref_trunc_len] = ...
    deal('resources/ARIR_processed/Anechoic_KEMAR_SrcEar.sofa', [], []);

azim_align_frac_sm = 24; % in fractional octaves
azim_align_freq_rng = [200, 20e3]; % in Hz

comp_filter_len = 1024; % in samples, target length of generated compensation filters
comp_filter_bits = 64; % in bits, WAV bit depth of exported compensation filters

comp_filter_dff_freq_rng = [0, 22e3]; % in Hz, for diffuse-field equalization
comp_filter_hmc_freq_rng = [0, 20e3]; % in Hz, for diffuse-field + Harman curve equalization
comp_filter_ref_freq_rng = [0, 21e3]; % in Hz, for reference equalization

plot_frac_sm = 24; % in fractional octaves
plot_norm_freq_rng = [50, 500]; % in Hz
plot_export_dir = 'plots/4_Equalization';

global DO_EXPORT_PLOT DO_EXPORT_FILTER DO_EXPORT_SOFA DO_EXPORT_SSR %#ok<*GVMIS> 
DO_EXPORT_PLOT   = true;
DO_EXPORT_FILTER = true;
DO_EXPORT_SOFA   = true;
DO_EXPORT_SSR    = true;

% DO_EXPORT_PLOT   = false;
% DO_EXPORT_FILTER = false;
% DO_EXPORT_SOFA   = false;
% DO_EXPORT_SSR    = false;

%% load files
tic; % start measuring execution time
SOFAstart;

fprintf('Loading public file "%s" ... ', hrir_pub_file);
if endsWith(hrir_pub_file, '.mat')
    error('Not yet implemented.');
elseif endsWith(hrir_pub_file, '.sofa')
    hrir_pub = SOFAload(hrir_pub_file);
    fs = hrir_pub.Data.SamplingRate;
    if size(hrir_pub.SourcePosition, 1) ~= 1
        hrir_grid = hrir_pub.SourcePosition(:, 1:2);
    else
        error('Not yet implemented.');
    end
    hrir_grid(:, 2) = 90 - hrir_grid(:, 2); % elevation to colatitude
    try
        hrir_quadWeights = hrir_pub.SourceQuadWeight;
    catch
        hrir_quadWeights = [];
    end
else
    error('Unknown data file format.');
end
fprintf('done.\n');

fprintf('Loading reference file "%s" ... ', hrir_ref_file);
if endsWith(hrir_ref_file, '.mat')
    hrir_ref = load(hrir_ref_file);
    if isfield(hrir_ref, 'irChOne')
        % arrange according to structure in SOFA objects ... although it
        % doesn't make sense ...
        hrir_ref.Data.IR = permute(hrir_ref.irChOne, [3, 2, 1]);
    elseif isfield(hrir_ref, 'hrirs_l')
        % arrange according to structure in SOFA objects ... although it
        % doesn't make sense ...
        hrir_ref.Data.IR = permute(cat(3, hrir_ref.hrirs_l, hrir_ref.hrirs_r), [2, 3, 1]);
        if ~isfield(hrir_ref, 'azimuth')
            if size(hrir_ref.Data.IR, 1) == 360
                % guess expected azimuth orientations in radians
                % 0 .. 179, -180 .. -1
                hrir_ref.azimuth = deg2rad(sph2nav(1 : 360) - 1);
            else
                error('Azimuth orintations not given.');
            end
        end
    end
    fs_ref = hrir_ref.fs;
    [hor_grid, az_idx] = sort(rad2deg(hrir_ref.azimuth.')); % azimuth in deg
    hor_grid(:, 2) = 90; % colatitude in deg
    az_idx = flip(az_idx); % make compatible with "SourcePosition" convention
    hrir_ref_irs_hor = get_SOFA_IRs(hrir_ref);
    hrir_ref_irs_hor = hrir_ref_irs_hor(:, az_idx, :);
    clear az_idx;
elseif endsWith(hrir_ref_file, '.sofa')
    hrir_ref = SOFAload(hrir_ref_file);
    hrir_ref_irs_hor = get_SOFA_IRs(hrir_ref);
    fs_ref = hrir_ref.Data.SamplingRate;
    if size(hrir_ref.ListenerView, 1) ~= 1
        hor_grid = hrir_ref.ListenerView(:, 1:2); % in deg
        % make compatible with "SourcePosition" convention
        hor_grid(:, 2) = -hor_grid(:, 2);
    elseif size(hrir_ref.SourcePosition, 1) ~= 1
        hor_grid = hrir_ref.SourcePosition(:, 1:2); % in deg
    else
        error('Not yet implemented.');
    end
    % make compatible with "SourcePosition" convention
    hor_grid(:, 1) = 360 - hor_grid(:, 1);
    hor_grid(:, 2) = 90 - hor_grid(:, 2); % elevation to colatitude
else
    error('Unknown data file format.');
end
if fs_ref ~= fs
    fprintf('resampling from %d to %d Hz ... ', fs_ref, fs);
    hrir_ref_irs_hor = resample(hrir_ref_irs_hor, fs, fs_ref);
end
clear fs_ref;
assert(all(hor_grid(:, 2) == 90), ...
    'Processing of non-horizontal reference dataset not implmentend yet.');
% change to "navigational" azimuth grid, since it looks nicer
hor_grid(:, 1) = sph2nav(hor_grid(:, 1));
hor_grid(hor_grid == 180) = -180; % for nicer plotting
fprintf('done.\n');

% parse file names
[~, hrir_ref_file, ~] = fileparts(hrir_ref_file);
[data_export_dir, hrir_pub_file, ~] = fileparts(hrir_pub_file);
hrir_adj_out_file = [hrir_pub_file, '_adjusted'];
hrir_dffEQ_out_file = [hrir_pub_file, '_diffuse'];
hrir_hmcEQ_out_file = [hrir_pub_file, '_harman'];
hrir_refEQ_out_file = [hrir_pub_file, '_reference'];
plot_file = fullfile(plot_export_dir, [hrir_pub_file, '_WITH_', hrir_ref_file]);
fprintf('\n');

%% preprocess reference HRIRs
fprintf('Normalizing published HRIR amplitude ... ');
hrir_pub_irs = get_SOFA_IRs(hrir_pub);
hrir_pub_level = max(abs(hrir_pub_irs), [], 'all');
fprintf('by %.1f dB of maximum ... ', -db(hrir_pub_level));
hrir_pub_irs = hrir_pub_irs / hrir_pub_level;
clear hrir_pub_level;
fprintf('done.\n');

fprintf('Equalizing reference HRIR amplitude ... ');
% use Root-sum-of-squares to better account for different IR lengths
hrir_pub_level = mean(rssq(hrir_pub_irs), 'all');
fprintf('to %.1f dB of adjusted HRIR average ... ', db(hrir_pub_level));
hrir_ref_irs_hor = hrir_ref_irs_hor * hrir_pub_level / mean(rssq(hrir_ref_irs_hor), 'all');
clear hrir_pub_level;
fprintf('done.\n');

fprintf('Applying low-frequency extension to reference HRIRs ... ');
if ~isempty(hrir_ref_lf_rng)
    if ~isempty(hrir_ref_trunc_len)
        fprintf('at %d samples ... ', hrir_ref_trunc_len);
    end
    hrir_ref_irs_hor = apply_LF_extension( ...
        hrir_ref_irs_hor, fs, hrir_ref_lf_rng, hrir_ref_trunc_len);
    fprintf('done.\n');
else
    fprintf('skipped.\n');
    fprintf('Truncating reference HRIRs ... ');
    if ~isempty(hrir_ref_trunc_len)
        fprintf('to %d samples ... ', hrir_ref_trunc_len);
        hrir_ref_irs_hor = hrir_ref_irs_hor(1:hrir_ref_trunc_len, :, :);
        fprintf('done.\n');
    else
        fprintf('skipped.\n');
    end
end
fprintf('\n');

%% generate adjusted HRIRs
fprintf('Applying circshift to adjusted HRIRs ... ');
hrir_adj_irs = hrir_pub_irs;
hrir_adj_sum_etc = db(sum(abs(hrir_adj_irs), [2, 3]));
hrir_adj_shift = find(hrir_adj_sum_etc > 0, 1, 'first');
if hrir_adj_shift > 1
    fprintf('by %d samples of first non-zero sample ... ', hrir_adj_shift);
else
    [~, hrir_adj_shift] = min(hrir_adj_sum_etc);
    if hrir_adj_shift > size(hrir_adj_irs, 1) / 2
        hrir_adj_shift = hrir_adj_shift - size(hrir_adj_irs, 1) ;
    end
    fprintf('by %d samples of lowest ETC energy sample ... ', hrir_adj_shift);
end
hrir_adj_irs = circshift(hrir_adj_irs, -hrir_adj_shift);
clear hrir_adj_sum_etc hrir_adj_shift;
fprintf('done.\n');

fprintf('Applying windowing of %d samples to adjusted HRIRs ... ', hrir_pub_win_len);
if hrir_pub_win_len
    % Apply fade-in and fade-out window
    win = cos(linspace(pi/2, 0, hrir_pub_win_len).').^2;
    hrir_adj_irs(1:hrir_pub_win_len, :, :) = ...
        hrir_adj_irs(1:hrir_pub_win_len, :, :) .* win;
    win = cos(linspace(0, pi/2, hrir_pub_win_len).').^2;
    hrir_adj_irs(end-hrir_pub_win_len+1:end, :, :) = ...
        hrir_adj_irs(end-hrir_pub_win_len+1:end, :, :) .* win;
    clear win;
    fprintf('done.\n');
else
    fprintf('skipped.\n');
end

% fprintf('Applying zero-padding ... ');
% ir_len = max([size(hrir_ref_irs_hor, 1), size(hrir_adj_irs, 1)]);
% fprintf('to %d samples of longest IR ... ', ir_len);
% hrir_ref_irs_hor(end+1:ir_len, :, :) = 0;
% hrir_adj_irs(end+1:ir_len, :, :) = 0;
% clear ir_len;
% fprintf('done.\n');

% fprintf('Removing zeros ... ');
% ir_len = min([size(hrir_ref_irs_hor, 1), size(hrir_adj_irs, 1)]);
% fprintf('after %d samples of shortest IR ... ', ir_len);
% hrir_ref_irs_hor = hrir_ref_irs_hor(1:ir_len, :, :);
% hrir_adj_irs = hrir_adj_irs(1:ir_len, :, :);
% clear ir_len;
% fprintf('done.\n');

% update SOFA attributes
hrir_adj = hrir_pub;
hrir_adj.Data.IR = []; % remove data to make clear it has to be done later
comment = sprintf('H. Helmholz: circshifted and windowed');
if isfield(hrir_adj, 'GLOBAL_Comment')
    hrir_adj.GLOBAL_Comment = [hrir_adj.GLOBAL_Comment, '; ', comment];
else
    hrir_adj.GLOBAL_Comment = comment;
end
clear comment;
fprintf('\n');

%% adapt reference dataset orientation
fprintf('Transforming adjusted HRIRs into SHs ... at N=%d ... ', hrir_pub_sh_order);
for e = 1 : size(hrir_adj_irs, 3) % each ear
    if isempty(hrir_quadWeights)
        % transformation with Spherical-Harmonic-Transform and without quadrature weigths
        [hrir_adj_sh_SHT, ~] = leastSquaresSHT(hrir_pub_sh_order, ...
            hrir_adj_irs(:, :, e).', deg2rad(hrir_grid), 'real');
    else
        % transformation with Spherical-Harmonic-Transform and quadrature weigths
        [hrir_adj_sh_SHT, ~] = directSHT(hrir_pub_sh_order, ...
            hrir_adj_irs(:, :, e).', deg2rad(hrir_grid), 'real', hrir_quadWeights);
    end
    hrir_adj_sh(:, :, e) = hrir_adj_sh_SHT.'; %#ok<*SAGROW> 
    clear hrir_adj_sh_SHT;
    % % transform with AKtools and without quadrature weigths
    % % (different SH convention to Spherical-Harmonic-Transform)
    % hrir_adj_sh(:, :, e) = AKsht(hrir_adj_irs(:, :, e), ...
    %     false, hrir_grid, hrir_pub_sh_order, 'complex', [], true, 'real').'; %#ok<*SAGROW> 
end; clear e;
fprintf('done.\n');

fprintf('Gathering horizontal IRs ... ');
% gathering horizontal IRs
for e = 1 : size(hrir_adj_sh, 3) % each ear
    % transformation with Spherical-Harmonic-Transform
    hrir_adj_irs_hor(:, :, e) = inverseSHT(hrir_adj_sh(:, :, e).', ...
        deg2rad(hor_grid), 'real').';
    % % transformation with AKtools
    % % (result is identical to Spherical-Harmonic-Transform)
    % hrir_adj_irs_hor(:, :, e) = AKisht(hrir_adj_sh(:, :, e).', ...
    %     false, hor_grid, 'complex', [], true, 'real');
end; clear e;
fprintf('done.\n');

fprintf('Computing azimuth alignment ... ');
[azim_min_shift, azim_min_shift_ind, azim_specs_diff, azim_specs_diff_mean] = ...
    compute_azim_alignment(hor_grid(:, 1), hrir_ref_irs_hor, ...
    hrir_adj_irs_hor, fs, azim_align_frac_sm, azim_align_freq_rng);
fprintf(['found mismatch minima at [%.1f, %.1f] deg ', ...
    'for left / right ear individually ... '], azim_min_shift_ind);
fprintf('done.\n');

fprintf('Aligning reference HRIR azimuth ... ');
fprintf('by %.1f deg for combined minimum at both ears ... ', azim_min_shift);
hrir_ref_irs_hor = circshift(hrir_ref_irs_hor, -round(azim_min_shift), 2);
fprintf('done.\n');

fprintf('Generating plot "%s" ... ', plot_file);
[fig_dir, fig_name, ~] = fileparts(plot_file); %#ok<*ASGLU> 
fig = AKf();
set(fig, 'NumberTitle', 'Off', 'Name', fig_name);
title_str = 'Differences averaged over incidence directions';
if azim_align_frac_sm
    title_str = sprintf('%s   (1/%d oct. smoothing)', title_str, azim_align_frac_sm);
end
plot_azim_alignment(hor_grid(:, 1), azim_min_shift, azim_min_shift_ind, ...
    azim_specs_diff, azim_specs_diff_mean, fs, title_str, azim_align_freq_rng, true);
if DO_EXPORT_PLOT
    fprintf('exporting ... ');
    [~, ~] = mkdir(fig_dir); % ignore warning if directory already exists
    fig_name = fullfile(fig_dir, [fig_name, '.pdf']);
    exportgraphics(fig, fig_name);
end
clear fig_dir fig_name fig title_str;
clear azim_min_shift azim_min_shift_ind azim_specs_diff azim_specs_diff_mean;
fprintf('done.\n');
fprintf('\n');

%% process diffuse-field compensation 
fprintf('Computing diffuse-field compensation filter ... ');
% computing spectral RMS in SH domainuitt
hrir_dffEQ_avg_all = compute_spectral_average_SH_IRs(hrir_adj_sh);
% TODO: Decide if inverse filter design should be done more sophisticated, 
% e.g. ﻿Kirkeby and Nelson least-mean-square regularisation, ﻿with in-band and 
% out-band regularisation of 25 dB and 5 dB
[hrir_dffEQ_comp_min, hrir_dffEQ_comp_lin] = ...
    compute_and_plot_compensation_filter([plot_file, '_filter_diffuse'], ...
    hrir_dffEQ_avg_all, fs, comp_filter_len, comp_filter_dff_freq_rng);
clear hrir_adj_sh;
fprintf('done.\n');

if DO_EXPORT_FILTER
    out_file = fullfile(data_export_dir, [hrir_dffEQ_out_file, '_filter_min.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_dffEQ_comp_min, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_dffEQ_out_file, '_filter_lin.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_dffEQ_comp_lin, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    clear out_file;
else
    disp('Exporting filter files ... skipped.'); %#ok<*UNRCH> 
end

fprintf('Applying diffuse-field compensation filter ... ');
hrir_dffEQ_irs = hrir_adj_irs;
% comment = 'minimum phase';
% % result has identical length to input data, which is fine in case the
% % minimum phase filter is used
% hrir_dffEQ_irs = filter(hrir_dffEQ_comp_min, 1, hrir_dffEQ_irs);
comment = 'linear phase';
% zero-pad before
hrir_dffEQ_irs(end+1 : size(hrir_dffEQ_irs, 1) + size(hrir_dffEQ_comp_lin, 1) - 1, :, :) = 0;
% apply filter
hrir_dffEQ_irs = filter(hrir_dffEQ_comp_lin, 1, hrir_dffEQ_irs);
% % remove filter delay
% hrir_dffEQ_irs = hrir_dffEQ_irs(ceil(size(hrir_dffEQ_comp_lin, 1) / 2) ...
%     : end - floor(size(hrir_dffEQ_comp_lin, 1) / 2), :, :);

% update SOFA attributes
fprintf([comment, ' ... ']);
hrir_dffEQ = hrir_pub;
hrir_dffEQ.Data.IR = []; % remove data to make clear it has to be done later
comment = sprintf('H. Helmholz: diffuse-field equalized (%s)', comment);
if isfield(hrir_dffEQ, 'GLOBAL_Comment')
    hrir_dffEQ.GLOBAL_Comment = [hrir_dffEQ.GLOBAL_Comment, '; ', comment];
else
    hrir_dffEQ.GLOBAL_Comment = comment;
end
clear comment;
fprintf('done.\n');
fprintf('\n');

%% process Harman curve compensation 
fprintf('Computing Harman curve compensation filter ... ');
% get data from file 
hrir_hmcEQ_target = get_Harman_curve_IR(size(hrir_dffEQ_avg_all, 1), fs);
% combine with diffuse field target
hrir_hmcEQ_avg_all = ifft(abs(fft(hrir_dffEQ_avg_all) ./ fft(hrir_hmcEQ_target)));
[hrir_hmcEQ_comp_min, hrir_hmcEQ_comp_lin] = ...
    compute_and_plot_compensation_filter([plot_file, '_filter_harman'], ...
    hrir_hmcEQ_avg_all, fs, comp_filter_len, comp_filter_hmc_freq_rng);
clear hrir_dffEQ_avg_all hrir_hmcEQ_target;
fprintf('done.\n');

if DO_EXPORT_FILTER
    out_file = fullfile(data_export_dir, [hrir_hmcEQ_out_file, '_filter_min.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_hmcEQ_comp_min, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_hmcEQ_out_file, '_filter_lin.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_hmcEQ_comp_lin, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    clear out_file;
else
    disp('Exporting filter files ... skipped.'); %#ok<*UNRCH> 
end

fprintf('Applying Harman curve compensation filter ... ');
hrir_hmcEQ_irs = hrir_adj_irs;
% comment = 'minimum phase';
% % result has identical length to input data, which is fine in case the
% % minimum phase filter is used
% hrir_hmcEQ_irs = filter(hrir_hmcEQ_comp_min, 1, hrir_hmcEQ_irs);
comment = 'linear phase';
% zero-pad before
hrir_hmcEQ_irs(end+1 : size(hrir_hmcEQ_irs, 1) + size(hrir_hmcEQ_comp_lin, 1) - 1, :, :) = 0;
% apply filter
hrir_hmcEQ_irs = filter(hrir_hmcEQ_comp_lin, 1, hrir_hmcEQ_irs);
% % remove filter delay
% hrir_hmcEQ_irs = hrir_hmcEQ_irs(ceil(size(hrir_hmcEQ_comp_lin, 1) / 2) ...
%     : end - floor(size(hrir_hmcEQ_comp_lin, 1) / 2), :, :);

% update SOFA attributes
fprintf([comment, ' ... ']);
hrir_hmcEQ = hrir_pub;
hrir_hmcEQ.Data.IR = []; % remove data to make clear it has to be done later
comment = sprintf('H. Helmholz: diffuse-field + Harman curve equalized (%s)', comment);
if isfield(hrir_hmcEQ, 'GLOBAL_Comment')
    hrir_hmcEQ.GLOBAL_Comment = [hrir_hmcEQ.GLOBAL_Comment, '; ', comment];
else
    hrir_hmcEQ.GLOBAL_Comment = comment;
end
clear comment;
fprintf('done.\n');
fprintf('\n');

%% process reference compensation
fprintf('Computing reference compensation filter ... ');
% computing horizontal differences
hrir_adj_diff_hor = compute_spectral_difference_IRs(hrir_adj_irs_hor, hrir_ref_irs_hor);
% computing horizontal average (with RMS)
hrir_adj_diff_hor = compute_spectral_average_IRs(hrir_adj_diff_hor);
% % computing horizontal average (with mean)
% [spec_adj_diff_hor, is_even] = AKboth2singleSidedSpectrum(fft(hrir_adj_diff_hor));
% spec_adj_diff_hor = squeeze(mean(spec_adj_diff_hor, 2));
% hrir_adj_diff_hor = ifft(AKsingle2bothSidedSpectrum(spec_adj_diff_hor, is_even));
% computing compensation filter
[hrir_refEQ_comp_min, hrir_refEQ_comp_lin, hrir_refEQ_compInv_min, hrir_refEQ_compInv_lin] = ...
    compute_and_plot_compensation_filter([plot_file, '_filter_reference'], ...
    hrir_adj_diff_hor, fs, comp_filter_len, comp_filter_ref_freq_rng);
clear hrir_adj_diff_hor hrir_adj_irs_hor;
fprintf('done.\n');

if DO_EXPORT_FILTER
    out_file = fullfile(data_export_dir, [hrir_refEQ_out_file, '_filter_min.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_refEQ_comp_min, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_refEQ_out_file, '_filter_lin.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_refEQ_comp_lin, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_refEQ_out_file, '_filterInv_min.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_refEQ_compInv_min, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_refEQ_out_file, '_filterInv_lin.wav']);
    fprintf('Exporting file "%s" ... ', out_file);
    audiowrite(out_file, hrir_refEQ_compInv_lin, fs, 'BitsPerSample', comp_filter_bits);
    fprintf('done.\n');

    clear out_file;
else
    disp('Exporting filter files ... skipped.'); 
end

fprintf('Applying reference compensation filter ... ');
hrir_refEQ_irs = hrir_adj_irs;
% comment = 'minimum phase';
% % result has identical length to input data, which is fine in case the
% % minimum phase filter is used
% hrir_adj_irs = filter(hrir_adj_comp_min, 1, hrir_adj_irs);
comment = 'linear phase';
% zero-pad before
hrir_refEQ_irs(end+1 : size(hrir_refEQ_irs, 1) + comp_filter_len - 1, :, :) = 0;
% apply filter
hrir_refEQ_irs = filter(hrir_refEQ_comp_lin, 1, hrir_refEQ_irs);
% % remove filter delay
% hrir_refEQ_irs = hrir_refEQ_irs(ceil(comp_filter_len / 2) : end - floor(comp_filter_len / 2), :, :);

% update SOFA attributes
fprintf([comment, ' ... ']);
hrir_refEQ = hrir_pub;
hrir_refEQ.Data.IR = []; % remove data to make clear it has to be done later
comment = sprintf('H. Helmholz: equalized wrt. %s (%s)', hrir_ref_file, comment);
if isfield(hrir_refEQ, 'GLOBAL_Comment')
    hrir_refEQ.GLOBAL_Comment = [hrir_refEQ.GLOBAL_Comment, '; ', comment];
else
    hrir_refEQ.GLOBAL_Comment = comment;
end
clear comment;
fprintf('done.\n');
fprintf('\n');

%% export SOFA files
fprintf('Equalizing HRIR amplitudes ... ');
% use Root-sum-of-squares to better account for different IR lengths
hrir_pub_level = mean(rssq(hrir_pub_irs), 'all');
fprintf('to %.1f dB of adjusted HRIR average ... ', db(hrir_pub_level));
hrir_ref_irs_hor = hrir_ref_irs_hor * hrir_pub_level / mean(rssq(hrir_ref_irs_hor), 'all');
hrir_adj_irs = hrir_adj_irs * hrir_pub_level / mean(rssq(hrir_adj_irs), 'all');
hrir_dffEQ_irs = hrir_dffEQ_irs * hrir_pub_level / mean(rssq(hrir_dffEQ_irs), 'all');
hrir_hmcEQ_irs = hrir_hmcEQ_irs * hrir_pub_level / mean(rssq(hrir_hmcEQ_irs), 'all');
hrir_refEQ_irs = hrir_refEQ_irs * hrir_pub_level / mean(rssq(hrir_refEQ_irs), 'all');
clear hrir_pub_level;
fprintf('done.\n');

fprintf('Updating HRIR SOFA attributes ...');
hrir_adj = update_SOFA_IRs(hrir_adj, hrir_adj_irs);
hrir_adj.API.N = size(hrir_adj.Data.IR, 3);
hrir_dffEQ = update_SOFA_IRs(hrir_dffEQ, hrir_dffEQ_irs);
hrir_dffEQ.API.N = size(hrir_dffEQ.Data.IR, 3);
hrir_hmcEQ = update_SOFA_IRs(hrir_hmcEQ, hrir_hmcEQ_irs);
hrir_hmcEQ.API.N = size(hrir_hmcEQ.Data.IR, 3);
hrir_refEQ = update_SOFA_IRs(hrir_refEQ, hrir_refEQ_irs);
hrir_refEQ.API.N = size(hrir_refEQ.Data.IR, 3);
fprintf('done.\n');

if DO_EXPORT_SOFA
    out_file = fullfile(data_export_dir, [hrir_adj_out_file, '.sofa']);
    fprintf('Exporting file "%s" ... ', out_file); 
    SOFAsave(out_file, hrir_adj);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_dffEQ_out_file, '.sofa']);
    fprintf('Exporting file "%s" ... ', out_file);
    SOFAsave(out_file, hrir_dffEQ);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_hmcEQ_out_file, '.sofa']);
    fprintf('Exporting file "%s" ... ', out_file);
    SOFAsave(out_file, hrir_hmcEQ);
    fprintf('done.\n');

    out_file = fullfile(data_export_dir, [hrir_refEQ_out_file, '.sofa']);
    fprintf('Exporting file "%s" ... ', out_file);
    SOFAsave(out_file, hrir_refEQ);
    fprintf('done.\n');

    clear out_file;
else
    disp('Exporting SOFA files ... skipped.');
end
fprintf('\n');

%% gather HRIRs
fprintf('Transforming all HRIRs into SHs ... at N=%d ... ', hrir_pub_sh_order);
for e = 1 : size(hrir_adj_irs, 3) % each ear
    % transformation with Spherical-Harmonic-Transform
    if isempty(hrir_quadWeights) % without quadrature weigths
        [hrir_pub_sh_SHT, ~] = leastSquaresSHT(hrir_pub_sh_order, ...
            hrir_pub_irs(:, :, e).', deg2rad(hrir_grid), 'real');
        [hrir_adj_sh_SHT, ~] = leastSquaresSHT(hrir_pub_sh_order, ...
            hrir_adj_irs(:, :, e).', deg2rad(hrir_grid), 'real');
        [hrir_dffEQ_sh_SHT, ~] = leastSquaresSHT(hrir_pub_sh_order, ...
            hrir_dffEQ_irs(:, :, e).', deg2rad(hrir_grid), 'real');
        [hrir_hmcEQ_sh_SHT, ~] = leastSquaresSHT(hrir_pub_sh_order, ...
            hrir_hmcEQ_irs(:, :, e).', deg2rad(hrir_grid), 'real');
        [hrir_refEQ_sh_SHT, ~] = leastSquaresSHT(hrir_pub_sh_order, ...
            hrir_refEQ_irs(:, :, e).', deg2rad(hrir_grid), 'real');
    else % with quadrature weigths
        [hrir_pub_sh_SHT, ~] = directSHT(hrir_pub_sh_order, ...
            hrir_adj_irs(:, :, e).', deg2rad(hrir_grid), 'real', hrir_quadWeights);
        [hrir_adj_sh_SHT, ~] = directSHT(hrir_pub_sh_order, ...
            hrir_adj_irs(:, :, e).', deg2rad(hrir_grid), 'real', hrir_quadWeights);
        [hrir_dffEQ_sh_SHT, ~] = directSHT(hrir_pub_sh_order, ...
            hrir_dffEQ_irs(:, :, e).', deg2rad(hrir_grid), 'real', hrir_quadWeights);
        [hrir_hmcEQ_sh_SHT, ~] = directSHT(hrir_pub_sh_order, ...
            hrir_hmcEQ_irs(:, :, e).', deg2rad(hrir_grid), 'real', hrir_quadWeights);
        [hrir_refEQ_sh_SHT, ~] = directSHT(hrir_pub_sh_order, ...
            hrir_refEQ_irs(:, :, e).', deg2rad(hrir_grid), 'real', hrir_quadWeights);
    end
    hrir_pub_sh(:, :, e) = hrir_pub_sh_SHT.';
    hrir_adj_sh(:, :, e) = hrir_adj_sh_SHT.';
    hrir_dffEQ_sh(:, :, e) = hrir_dffEQ_sh_SHT.';
    hrir_hmcEQ_sh(:, :, e) = hrir_hmcEQ_sh_SHT.';
    hrir_refEQ_sh(:, :, e) = hrir_refEQ_sh_SHT.';
    clear hrir_pub_sh_SHT hrir_adj_sh_SHT hrir_dffEQ_sh_SHT hrir_hmcEQ_sh_SHT hrir_refEQ_sh_SHT;
    % % transform with AKtools and without quadrature weigths
    % % (different SH convention to Spherical-Harmonic-Transform)
    % hrir_pub_sh(:, :, e) = AKsht(hrir_pub_irs(:, :, e), ...
    %     false, hrir_grid, hrir_pub_sh_order, 'complex', [], true, 'real').';
    % hrir_adj_sh(:, :, e) = AKsht(hrir_adj_irs(:, :, e), ...
    %     false, hrir_grid, hrir_pub_sh_order, 'complex', [], true, 'real').';
    % hrir_dffEQ_sh(:, :, e) = AKsht(hrir_dffEQ_irs(:, :, e), ...
    %     false, hrir_grid, hrir_pub_sh_order, 'complex', [], true, 'real').';
    % hrir_hmcEQ_sh(:, :, e) = AKsht(hrir_hmcEQ_irs(:, :, e), ...
    %     false, hrir_grid, hrir_pub_sh_order, 'complex', [], true, 'real').';
    % hrir_refEQ_sh(:, :, e) = AKsht(hrir_refEQ_irs(:, :, e), ...
    %     false, hrir_grid, hrir_pub_sh_order, 'complex', [], true, 'real').';
end; clear e;
fprintf('done.\n');

fprintf('Gathering frontal HRIRs ... ');
[~, idx] = min(abs(hor_grid(:, 1)));
hrir_ref_irs_fro = squeeze(hrir_ref_irs_hor(:, idx, :));
for e = 1 : size(hrir_pub_sh, 3) % each ear
    % transformation with Spherical-Harmonic-Transform
    hrir_pub_irs_fro(:, e) = inverseSHT(hrir_pub_sh(:, :, e).', ...
        deg2rad([0, 90]), 'real').';
    hrir_adj_irs_fro(:, e) = inverseSHT(hrir_adj_sh(:, :, e).', ...
        deg2rad([0, 90]), 'real').';
    hrir_dffEQ_irs_fro(:, e) = inverseSHT(hrir_dffEQ_sh(:, :, e).', ...
        deg2rad([0, 90]), 'real').';
    hrir_hmcEQ_irs_fro(:, e) = inverseSHT(hrir_hmcEQ_sh(:, :, e).', ...
        deg2rad([0, 90]), 'real').';
    hrir_refEQ_irs_fro(:, e) = inverseSHT(hrir_refEQ_sh(:, :, e).', ...
        deg2rad([0, 90]), 'real').';
    % % transformation with AKtools
    % % (result is identical to Spherical-Harmonic-Transform)
    % hrir_pub_irs_fro(:, e) = AKisht(hrir_pub_sh(:, :, e).', ...
    %     false, [0, 90], 'complex', [], true, 'real');
    % hrir_adj_irs_fro(:, e) = AKisht(hrir_adj_sh(:, :, e).', ...
    %     false, [0, 90], 'complex', [], true, 'real');
    % hrir_dffEQ_irs_fro(:, e) = AKisht(hrir_dffEQ_sh(:, :, e).', ...
    %     false, [0, 90], 'complex', [], true, 'real');
    % hrir_hmcEQ_irs_fro(:, e) = AKisht(hrir_hmcEQ_sh(:, :, e).', ...
    %     false, [0, 90], 'complex', [], true, 'real');
    % hrir_refEQ_irs_fro(:, e) = AKisht(hrir_refEQ_sh(:, :, e).', ...
    %     false, [0, 90], 'complex', [], true, 'real');
end; clear e;
clear idx;
fprintf('done.\n');

fprintf('Gathering horizontal HRIRs ... ');
for e = 1 : size(hrir_pub_sh, 3) % each ear
    % transformation with Spherical-Harmonic-Transform
    hrir_pub_irs_hor(:, :, e) = inverseSHT(hrir_pub_sh(:, :, e).', ...
        deg2rad(hor_grid), 'real').';
    hrir_adj_irs_hor(:, :, e) = inverseSHT(hrir_adj_sh(:, :, e).', ...
        deg2rad(hor_grid), 'real').';
    hrir_dffEQ_irs_hor(:, :, e) = inverseSHT(hrir_dffEQ_sh(:, :, e).', ...
        deg2rad(hor_grid), 'real').';
    hrir_hmcEQ_irs_hor(:, :, e) = inverseSHT(hrir_hmcEQ_sh(:, :, e).', ...
        deg2rad(hor_grid), 'real').';
    hrir_refEQ_irs_hor(:, :, e) = inverseSHT(hrir_refEQ_sh(:, :, e).', ...
        deg2rad(hor_grid), 'real').';
    % % transformation with AKtools
    % % (result is identical to Spherical-Harmonic-Transform)
    % hrir_pub_irs_hor(:, :, e) = AKisht(hrir_pub_sh(:, :, e).', ...
    %     false, hor_grid, 'complex', [], true, 'real');
    % hrir_adj_irs_hor(:, :, e) = AKisht(hrir_adj_sh(:, :, e).', ...
    %     false, hor_grid, 'complex', [], true, 'real');
    % hrir_dffEQ_irs_hor(:, :, e) = AKisht(hrir_dffEQ_sh(:, :, e).', ...
    %     false, hor_grid, 'complex', [], true, 'real');
    % hrir_hmcEQ_irs_hor(:, :, e) = AKisht(hrir_hmcEQ_sh(:, :, e).', ...
    %     false, hor_grid, 'complex', [], true, 'real');
    % hrir_refEQ_irs_hor(:, :, e) = AKisht(hrir_refEQ_sh(:, :, e).', ...
    %     false, hor_grid, 'complex', [], true, 'real');
end; clear e;
fprintf('done.\n');

if DO_EXPORT_SSR
    % adjust level
    max_amp = max(abs([hrir_ref_irs_hor; hrir_pub_irs_hor; hrir_adj_irs_hor; ...
        hrir_dffEQ_irs_hor; hrir_refEQ_irs_hor]), [], 'all');
    export_SSR_BRIRs(fullfile(data_export_dir, hrir_ref_file), ...
        hrir_ref_irs_hor / max_amp, fs);
    export_SSR_BRIRs(fullfile(data_export_dir, hrir_pub_file), ...
        hrir_pub_irs_hor / max_amp, fs);
    export_SSR_BRIRs(fullfile(data_export_dir, hrir_adj_out_file), ...
        hrir_adj_irs_hor / max_amp, fs);
    export_SSR_BRIRs(fullfile(data_export_dir, hrir_dffEQ_out_file), ...
        hrir_dffEQ_irs_hor / max_amp, fs);
    export_SSR_BRIRs(fullfile(data_export_dir, hrir_hmcEQ_out_file), ...
        hrir_hmcEQ_irs_hor / max_amp, fs);
    export_SSR_BRIRs(fullfile(data_export_dir, hrir_refEQ_out_file), ...
        hrir_refEQ_irs_hor / max_amp, fs);
    clear max_amp;
else
    disp('Exporting SSR files ... skipped.'); 
end
fprintf('\n');

%% compute spectral averages and differences
fprintf('Applying zero-padding (for plotting only) ... ');
hrir_ref_irs_hor_noPad = hrir_ref_irs_hor;
hrir_pub_irs_hor_noPad = hrir_pub_irs_hor;
hrir_adj_irs_hor_noPad = hrir_adj_irs_hor;
hrir_dffEQ_irs_hor_noPad = hrir_dffEQ_irs_hor;
hrir_hmcEQ_irs_hor_noPad = hrir_hmcEQ_irs_hor;
hrir_refEQ_irs_hor_noPad = hrir_refEQ_irs_hor;
ir_len = max([size(hrir_ref_irs_hor, 1), size(hrir_pub_irs_hor, 1), ...
    size(hrir_adj_irs_hor, 1), size(hrir_dffEQ_irs_hor, 1), ...
    size(hrir_hmcEQ_irs_hor, 1), size(hrir_refEQ_irs_hor, 1)]);
fprintf('to %d samples of longest HRIR ... ', ir_len);
hrir_pub_sh(end+1:ir_len, :, :) = 0;
hrir_adj_sh(end+1:ir_len, :, :) = 0;
hrir_dffEQ_sh(end+1:ir_len, :, :) = 0;
hrir_hmcEQ_sh(end+1:ir_len, :, :) = 0;
hrir_refEQ_sh(end+1:ir_len, :, :) = 0;
hrir_ref_irs_hor(end+1:ir_len, :, :) = 0;
hrir_pub_irs_hor(end+1:ir_len, :, :) = 0;
hrir_adj_irs_hor(end+1:ir_len, :, :) = 0;
hrir_dffEQ_irs_hor(end+1:ir_len, :, :) = 0;
hrir_hmcEQ_irs_hor(end+1:ir_len, :, :) = 0;
hrir_refEQ_irs_hor(end+1:ir_len, :, :) = 0;
hrir_ref_irs_fro(end+1:ir_len, :, :) = 0;
hrir_pub_irs_fro(end+1:ir_len, :, :) = 0;
hrir_adj_irs_fro(end+1:ir_len, :, :) = 0;
hrir_dffEQ_irs_fro(end+1:ir_len, :, :) = 0;
hrir_hmcEQ_irs_fro(end+1:ir_len, :, :) = 0;
hrir_refEQ_irs_fro(end+1:ir_len, :, :) = 0;
fprintf('done.\n');

fprintf('Applying spectral smoothing ... ');
hrir_ref_spec_fro = AKboth2singleSidedSpectrum(fft(hrir_ref_irs_fro));
hrir_pub_spec_fro = AKboth2singleSidedSpectrum(fft(hrir_pub_irs_fro));
hrir_adj_spec_fro = AKboth2singleSidedSpectrum(fft(hrir_adj_irs_fro));
hrir_dffEQ_spec_fro = AKboth2singleSidedSpectrum(fft(hrir_dffEQ_irs_fro));
hrir_hmcEQ_spec_fro = AKboth2singleSidedSpectrum(fft(hrir_hmcEQ_irs_fro));
hrir_refEQ_spec_fro = AKboth2singleSidedSpectrum(fft(hrir_refEQ_irs_fro));
spec_ref_irs_hor = AKboth2singleSidedSpectrum(fft(hrir_ref_irs_hor));
hrir_pub_spec_hor = AKboth2singleSidedSpectrum(fft(hrir_pub_irs_hor));
spec_adj_irs_hor = AKboth2singleSidedSpectrum(fft(hrir_adj_irs_hor));
hrir_dffEQ_spec_hor = AKboth2singleSidedSpectrum(fft(hrir_dffEQ_irs_hor));
hrir_hmcEQ_spec_hor = AKboth2singleSidedSpectrum(fft(hrir_hmcEQ_irs_hor));
hrir_refEQ_spec_hor = AKboth2singleSidedSpectrum(fft(hrir_refEQ_irs_hor));
if plot_frac_sm
    fprintf('of 1/%d octaves ... ', plot_frac_sm);
    hrir_ref_spec_fro = AKfractOctSmooth( ...
            hrir_ref_spec_fro, 'amp', fs, plot_frac_sm);
    hrir_pub_spec_fro = AKfractOctSmooth( ...
            hrir_pub_spec_fro, 'amp', fs, plot_frac_sm);
    hrir_adj_spec_fro = AKfractOctSmooth( ...
            hrir_adj_spec_fro, 'amp', fs, plot_frac_sm);
    hrir_dffEQ_spec_fro = AKfractOctSmooth( ...
            hrir_dffEQ_spec_fro, 'amp', fs, plot_frac_sm);
    hrir_hmcEQ_spec_fro = AKfractOctSmooth( ...
            hrir_hmcEQ_spec_fro, 'amp', fs, plot_frac_sm);
    hrir_refEQ_spec_fro = AKfractOctSmooth( ...
            hrir_refEQ_spec_fro, 'amp', fs, plot_frac_sm);
    for e = 1 : size(spec_ref_irs_hor, 3)
        spec_ref_irs_hor(:, :, e) = AKfractOctSmooth( ...
            spec_ref_irs_hor(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_pub_spec_hor(:, :, e) = AKfractOctSmooth( ...
            hrir_pub_spec_hor(:, :, e), 'amp', fs, plot_frac_sm);
        spec_adj_irs_hor(:, :, e) = AKfractOctSmooth( ...
            spec_adj_irs_hor(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_dffEQ_spec_hor(:, :, e) = AKfractOctSmooth( ...
            hrir_dffEQ_spec_hor(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_hmcEQ_spec_hor(:, :, e) = AKfractOctSmooth( ...
            hrir_hmcEQ_spec_hor(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_refEQ_spec_hor(:, :, e) = AKfractOctSmooth( ...
            hrir_refEQ_spec_hor(:, :, e), 'amp', fs, plot_frac_sm);
    end; clear e;
    fprintf('done.\n');
else
    fprintf('skipped.\n');
end

fprintf('Computing horizontal averages ... ');
hrir_ref_avg_hor = compute_spectral_average(spec_ref_irs_hor, 2);
hrir_pub_avg_hor = compute_spectral_average(hrir_pub_spec_hor, 2);
hrir_adj_avg_hor = compute_spectral_average(spec_adj_irs_hor, 2);
hrir_dffEQ_avg_hor = compute_spectral_average(hrir_dffEQ_spec_hor, 2);
hrir_hmcEQ_avg_hor = compute_spectral_average(hrir_hmcEQ_spec_hor, 2);
hrir_refEQ_avg_hor = compute_spectral_average(hrir_refEQ_spec_hor, 2);
fprintf('done.\n');

fprintf('Computing spherical averages ... ');
hrir_ref_avg_all = hrir_ref_avg_hor; % not actually spherical
hrir_pub_avg_all = compute_spectral_average_SH( ...
    AKboth2singleSidedSpectrum(fft(hrir_pub_sh)));
hrir_adj_avg_all = compute_spectral_average_SH( ...
    AKboth2singleSidedSpectrum(fft(hrir_adj_sh)));
hrir_dffEQ_avg_all = compute_spectral_average_SH( ...
    AKboth2singleSidedSpectrum(fft(hrir_dffEQ_sh)));
hrir_hmcEQ_avg_all = compute_spectral_average_SH( ...
    AKboth2singleSidedSpectrum(fft(hrir_hmcEQ_sh)));
hrir_refEQ_avg_all = compute_spectral_average_SH( ...
    AKboth2singleSidedSpectrum(fft(hrir_refEQ_sh)));
if plot_frac_sm
    for e = 1 : size(hrir_pub_avg_all, 3)
        hrir_pub_avg_all(:, :, e) = AKfractOctSmooth( ...
            hrir_pub_avg_all(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_adj_avg_all(:, :, e) = AKfractOctSmooth( ...
            hrir_adj_avg_all(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_dffEQ_avg_all(:, :, e) = AKfractOctSmooth( ...
            hrir_dffEQ_avg_all(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_hmcEQ_avg_all(:, :, e) = AKfractOctSmooth( ...
            hrir_hmcEQ_avg_all(:, :, e), 'amp', fs, plot_frac_sm);
        hrir_refEQ_avg_all(:, :, e) = AKfractOctSmooth( ...
            hrir_refEQ_avg_all(:, :, e), 'amp', fs, plot_frac_sm);
    end; clear e;
end
fprintf('done.\n');

fprintf('Computing spherical average differences ... ');
hrir_pub_avgDiff_all = compute_spectral_difference(hrir_pub_avg_all, hrir_ref_avg_all);
hrir_adj_avgDiff_all = compute_spectral_difference(hrir_adj_avg_all, hrir_ref_avg_all);
hrir_dffEQ_avgDiff_all = compute_spectral_difference(hrir_dffEQ_avg_all, hrir_ref_avg_all);
hrir_hmcEQ_avgDiff_all = compute_spectral_difference(hrir_hmcEQ_avg_all, hrir_ref_avg_all);
hrir_refEQ_avgDiff_all = compute_spectral_difference(hrir_refEQ_avg_all, hrir_ref_avg_all);
fprintf('done.\n');

fprintf('Computing frontal differences ... ');
hrir_pub_diff_fro = compute_spectral_difference(hrir_pub_spec_fro, hrir_ref_spec_fro);
hrir_adj_diff_fro = compute_spectral_difference(hrir_adj_spec_fro, hrir_ref_spec_fro);
hrir_dffEQ_diff_fro = compute_spectral_difference(hrir_dffEQ_spec_fro, hrir_ref_spec_fro);
hrir_hmcEQ_diff_fro = compute_spectral_difference(hrir_hmcEQ_spec_fro, hrir_ref_spec_fro);
hrir_refEQ_diff_fro = compute_spectral_difference(hrir_refEQ_spec_fro, hrir_ref_spec_fro);
fprintf('done.\n');

fprintf('Computing horizontal differences ... ');
hrir_pub_diff_hor = compute_spectral_difference(hrir_pub_spec_hor, spec_ref_irs_hor);
hrir_adj_diff_hor = compute_spectral_difference(spec_adj_irs_hor, spec_ref_irs_hor);
hrir_dffEQ_diff_hor = compute_spectral_difference(hrir_dffEQ_spec_hor, spec_ref_irs_hor);
hrir_hmcEQ_diff_hor = compute_spectral_difference(hrir_hmcEQ_spec_hor, spec_ref_irs_hor);
hrir_refEQ_diff_hor = compute_spectral_difference(hrir_refEQ_spec_hor, spec_ref_irs_hor);
fprintf('done.\n');

fprintf('Computing horizontal difference averages ... ');
hrir_pub_diffAvg_hor = compute_spectral_average(hrir_pub_diff_hor, 2);
hrir_adj_diffAvg_hor = compute_spectral_average(hrir_adj_diff_hor, 2);
hrir_dffEQ_diffAvg_hor = compute_spectral_average(hrir_dffEQ_diff_hor, 2);
hrir_hmcEQ_diffAvg_hor = compute_spectral_average(hrir_hmcEQ_diff_hor, 2);
hrir_refEQ_diffAvg_hor = compute_spectral_average(hrir_refEQ_diff_hor, 2);
fprintf('done.\n');
fprintf('\n');

%%
for e = 1:size(hrir_ref_irs_hor, 3)
    fprintf('Generating plot "%s" ... ', plot_file);
    [fig_dir, fig_name, ~] = fileparts(plot_file);
    fig = AKf();
    set(fig, 'NumberTitle', 'Off', 'Name', fig_name);
    tl = tiledlayout(fig, 3, 2, 'TileSpacing', 'tight', 'Padding', 'tight');
    drawnow;
    colormap('hot');

    nexttile(tl);
    plot_ETC_azims_IRs(hor_grid(:, 1), 1:size(hrir_ref_irs_hor_noPad, 1), hrir_ref_irs_hor_noPad, hrir_ref_file, e);
    set(gca, 'XDir', 'normal'); ylim([1, ir_len]);
    xticklabels(''); xlabel(''); ylabel('Time in samples'); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_ETC_azims_IRs(hor_grid(:, 1), 1:size(hrir_pub_irs_hor_noPad, 1), hrir_pub_irs_hor_noPad, hrir_pub_file, e);
    set(gca, 'XDir', 'normal'); ylim([1, ir_len]);
    xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    drawnow;
    nexttile(tl);
    plot_ETC_azims_IRs(hor_grid(:, 1), 1:size(hrir_adj_irs_hor_noPad, 1), hrir_adj_irs_hor_noPad, hrir_adj_out_file, e);
    set(gca, 'XDir', 'normal'); ylim([1, ir_len]);
    xticklabels(''); xlabel(''); ylabel('Time in samples'); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_ETC_azims_IRs(hor_grid(:, 1), 1:size(hrir_dffEQ_irs_hor_noPad, 1), hrir_dffEQ_irs_hor_noPad, hrir_dffEQ_out_file, e);
    set(gca, 'XDir', 'normal'); ylim([1, ir_len]);
    xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    drawnow;
    nexttile(tl);
    plot_ETC_azims_IRs(hor_grid(:, 1), 1:size(hrir_refEQ_irs_hor_noPad, 1), hrir_refEQ_irs_hor_noPad, hrir_refEQ_out_file, e);
    set(gca, 'XDir', 'normal'); ylim([1, ir_len]);
    ylabel('Time in samples'); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_ETC_azims_IRs(hor_grid(:, 1), 1:size(hrir_hmcEQ_irs_hor_noPad, 1), hrir_hmcEQ_irs_hor_noPad, hrir_hmcEQ_out_file, e);
    set(gca, 'XDir', 'normal'); ylim([1, ir_len]);
    yticklabels(''); ylabel('');
    drawnow;
    
    if DO_EXPORT_PLOT
        fprintf('exporting ... ');
        fig_name = fullfile(fig_dir, [fig_name, '.pdf']);
        exportgraphics(fig, fig_name, 'Append', true);
    end
    fprintf('done.\n');
end; clear e;
clear fig_name fig_dir fig tl;

%%
freqs = linspace(0, fs/2, size(spec_ref_irs_hor, 1));
for e = 1 : size(spec_ref_irs_hor, 3)
    fprintf('Generating plot "%s" ... ', plot_file);
    [fig_dir, fig_name, ~] = fileparts(plot_file);
    fig = AKf();
    set(fig, 'NumberTitle', 'Off', 'Name', fig_name);
    tl = tiledlayout(fig, 3, 2, 'TileSpacing', 'tight', 'Padding', 'tight');
    drawnow;
    colormap(AKcolormaps('RdBu', 128, true));

    % nexttile(tl);
    % plot_spec_azims(hor_grid(:, 1), freqs, spec_ref_irs_hor, hrir_ref_file, ...
    %     1, [freqs(2), fs/2], true, plot_norm_freq_rng);
    % if e == 2; set(gca, 'ColorMap', AKcolormaps('Greys', 128, true)); end
    % set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    % drawnow;
    % nexttile(tl);
    % plot_spec_azims(hor_grid(:, 1), freqs, spec_ref_irs_hor, hrir_ref_file, ...
    %     2, [freqs(2), fs/2], true, plot_norm_freq_rng);
    % if e == 1; set(gca, 'ColorMap', AKcolormaps('Greys', 128, true)); end
    % set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    % drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, spec_ref_irs_hor, hrir_ref_file, ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_pub_spec_hor, hrir_pub_file, ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, spec_adj_irs_hor, hrir_adj_out_file, ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_dffEQ_spec_hor, hrir_dffEQ_out_file, ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_refEQ_spec_hor, hrir_refEQ_out_file, ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_hmcEQ_spec_hor, hrir_hmcEQ_out_file, ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); yticklabels(''); ylabel('');
    drawnow;
    
    
    if DO_EXPORT_PLOT
        fprintf('exporting ... ');
        fig_name = fullfile(fig_dir, [fig_name, '.pdf']);
        exportgraphics(fig, fig_name, 'Append', true);
    end
    fprintf('done.\n');
end; clear e;
clear fig_name fig_dir fig tl freqs;

%%
title_str = '   Spectral Difference';
if plot_frac_sm
    title_str = sprintf('%s   1/%d oct. smoothing)', title_str, plot_frac_sm);
end
freqs = linspace(0, fs/2, size(hrir_pub_diff_hor, 1));
for e = 1 : size(hrir_pub_diff_hor, 3)
    fprintf('Generating plot "%s" ... ', plot_file);
    [fig_dir, fig_name, ~] = fileparts(plot_file);
    fig = AKf();
    set(fig, 'NumberTitle', 'Off', 'Name', fig_name);
    tl = tiledlayout(fig, 3, 2, 'TileSpacing', 'tight', 'Padding', 'tight');
    drawnow;
    colormap(AKcolormaps('RdBu', 128, true));
    
    nexttile(tl);
    axis off;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_pub_diff_hor, [hrir_pub_file, title_str], ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_adj_diff_hor, [hrir_adj_out_file, title_str], ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_dffEQ_diff_hor, [hrir_dffEQ_out_file, title_str], ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); xticklabels(''); xlabel(''); yticklabels(''); ylabel('');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_refEQ_diff_hor, [hrir_refEQ_out_file, title_str], ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); set(get(gca, 'ColorBar'), 'Location', 'WestOutside');
    drawnow;
    nexttile(tl);
    plot_spec_azims(hor_grid(:, 1), freqs, hrir_hmcEQ_diff_hor, [hrir_hmcEQ_out_file, title_str], ...
        e, [freqs(2), fs/2], true, plot_norm_freq_rng);
    set(gca, 'XDir', 'normal'); yticklabels(''); ylabel('');
    drawnow;

    if DO_EXPORT_PLOT
        fprintf('exporting ... ');
        fig_name = fullfile(fig_dir, [fig_name, '.pdf']);
        exportgraphics(fig, fig_name, 'Append', true);
    end
    fprintf('done.\n');
end; clear e;
clear fig_name fig_dir fig tl freqs title_str;

%%
fprintf('Generating plot "%s" ... ', plot_file);
[fig_dir, fig_name, ~] = fileparts(plot_file);
fig = AKf();
set(fig, 'Name', fig_name, 'NumberTitle', 'Off');

plot_spec_compare( ...
    {hrir_ref_file, hrir_pub_file, hrir_adj_out_file, hrir_dffEQ_out_file, hrir_hmcEQ_out_file, hrir_refEQ_out_file}, ...
    {hrir_ref_irs_fro, hrir_pub_irs_fro, hrir_adj_irs_fro, hrir_dffEQ_irs_fro, hrir_hmcEQ_irs_fro, hrir_refEQ_irs_fro}, ...
    {hrir_ref_avg_hor, hrir_pub_avg_hor, hrir_adj_avg_hor, hrir_dffEQ_avg_hor, hrir_hmcEQ_avg_hor, hrir_refEQ_avg_hor}, ...
    {hrir_ref_avg_all, hrir_pub_avg_all, hrir_adj_avg_all, hrir_dffEQ_avg_all, hrir_hmcEQ_avg_all, hrir_refEQ_avg_all}, ...
    fs, false, plot_frac_sm, true, plot_norm_freq_rng);

if DO_EXPORT_PLOT
    fig_name = fullfile(fig_dir, [fig_name, '.pdf']);
    fprintf('exporting ... ');
    exportgraphics(fig, fig_name, 'Append', true);
end
clear fig_dir fig_name fig;
fprintf('done.\n');

%%
fprintf('Generating plot "%s" ... ', plot_file);
[fig_dir, fig_name, ~] = fileparts(plot_file);
fig = AKf();
set(fig, 'Name', fig_name, 'NumberTitle', 'Off');

plot_spec_compare( ...
    {hrir_pub_file, hrir_adj_out_file, hrir_dffEQ_out_file, hrir_hmcEQ_out_file, hrir_refEQ_out_file}, ...
    {hrir_pub_diff_fro, hrir_adj_diff_fro, hrir_dffEQ_diff_fro, hrir_hmcEQ_diff_fro, hrir_refEQ_diff_fro}, ...
    {hrir_pub_diffAvg_hor, hrir_adj_diffAvg_hor, hrir_dffEQ_diffAvg_hor, hrir_hmcEQ_diffAvg_hor, hrir_refEQ_diffAvg_hor}, ...
    {hrir_pub_avgDiff_all, hrir_adj_avgDiff_all, hrir_dffEQ_avgDiff_all, hrir_hmcEQ_avgDiff_all, hrir_refEQ_avgDiff_all}, ...
    fs, true, plot_frac_sm, true, plot_norm_freq_rng);

if DO_EXPORT_PLOT
    fig_name = fullfile(fig_dir, [fig_name, '.pdf']);
    fprintf('exporting ... ');
    exportgraphics(fig, fig_name, 'Append', true);
end
clear fig_dir fig_name fig;
fprintf('done.\n');

%%
fprintf('\n ... finished in %.0fh %.0fm %.0fs.\n', ...
    toc/3600, mod(toc,3600)/60, mod(toc,60));
